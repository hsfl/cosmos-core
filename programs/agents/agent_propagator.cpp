/* 
 * Run this program from the ~/cosmos/realms/propagate folder.
 * The motherutc 60107.01 should set the initial position of the satellites over Hawaii.
 * agent_propagator '{"motherutc":60107.01}'
 * 
 * Specifying the cosmos_web_addr variable enables telem output to a cosmos web install.
 * If running the COSMOS Docker application, use the hostname "cosmos_telegraf".
 * Otherwise, manually specify the IP address of the cosmos web server, like "127.0.0.1".
 * agent_propagator '{"motherutc":60107.01, "cosmos_web_addr":"127.0.0.1"}'
 */

#include "physics/simulatorclass.h"
#include "agent/agentclass.h"
#include "support/jsonclass.h"
#include "support/datalib.h"
#include "support/beacon.h"
#include "support/packetcomm.h"
#include "support/packethandler.h"
#include "propagate_realm_defaults.h" // Auto-generated by cmake
#include <fstream>

using namespace Convert;

Vector calc_control_torque_b(Convert::qatt tatt, Convert::qatt catt, Vector moi, double portion);

Physics::Simulator *sim;
Agent *agent;
string realmname = "propagate";
qatt mothericrf;
cartpos mothereci;
// Simulation start time
double motherutc = 60107.01;
// Simulation end time, runs forever if set to 0.
double endutc = 0.;
// Multiplier for speed of simulation, 1 = realtime, 60 = 60x faster (1s realtime = 1min simtime), etc.
double speed=1.;
// Acceleration cap for thrusters
double maxaccel = .1;
double minaccel;
double offset = 0.;
double currentutc = 0.;
// Simulation discrete timestep, in seconds
double simdt = 1.;
double minaccelratio = 10;
// Physical constants
constexpr double d2s = 1./86400.;
constexpr double d2s2 = 1./(86400.*86400.);

string satfile = "sats.dat";
string targetfile = "targets.dat";
string tlefile = "tle.dat";

//// 0 : string of pearls
//// 1 : surrounding diamond
//// 2 : reverse string of pearls
//// 3 : high/low attraction experiment
//static uint8_t shapetype = 0;
//static double shapeseparation = 500.;
LsFit tattfit;
LsFit omegafit;
//static bool altprint = false;
int32_t parse_control(string args);
int32_t parse_sat(string args);
void check_propagator_setup_files();
void get_observation_windows();
void event_union_utc(vector<eventstruc*> events);

int net_port_in = 10080;
socket_channel net_channel_in;
string net_address_out;
int net_port_out = 10081;
socket_bus net_channel_out;

// For cosmos web
socket_channel cosmos_web_telegraf_channel, cosmos_web_api_channel;
const string TELEGRAF_ADDR = "cosmos_telegraf";
string cosmos_web_addr = "";
const int TELEGRAF_PORT = 10096;
const int API_PORT = 10097;
int32_t open_cosmos_web_sockets();
void add_sim_devices();
void reset_db();
void send_events_to_cosmos_web();
int32_t send_telem_to_cosmos_web(cosmosstruc* cinfo);


struct observation_window
{
    uint32_t type = 0;
    double utc = 0.;
    double duration = 0.;
    vector<string> elems;
};

int main(int argc, char *argv[])
{
    int32_t iretn = 0;
    FILE *fp;

    // initialize simulation agent
    motherutc = currentmjd();
    if (argc > 1)
    {
        parse_control(argv[1]);
    }

    // 

    agent = new Agent(realmname, "master", "propagate", 0.);
    agent->set_debug_level(0);

    // initialize simulator object
    sim = new Physics::Simulator();
    iretn = sim->GetError();
    if (iretn <0) {
        agent->debug_log.Printf("Error Creating Simulator: %s\n", cosmos_error_string(iretn).c_str());
        agent->shutdown();
        exit(iretn);
    }
    currentutc = motherutc;
    sim->Init(currentutc, simdt);

    // If simulation config files don't exist, copy default config files
    check_propagator_setup_files();

    // Load in satellites
    fp = fopen(satfile.c_str(), "r");
    char buf[150];
    while (fgets(buf, 149, fp) != nullptr)
    {
        parse_sat(buf);
    }

    // Load in targets
    fp = fopen(targetfile.c_str(), "r");
    if (fp != nullptr)
    {
        string line;
        line.resize(200);
        while (fgets((char *)line.data(), 200, fp) != nullptr)
        {
            vector<string> args = string_split(line, " \t\n");
            for (Physics::Simulator::StateList::iterator sit = sim->cnodes.begin(); sit != sim->cnodes.end(); sit++)
            {
                if (args.size() == 4)
                {
                    (*sit)->AddTarget(args[0], RADOF(stod(args[1])), RADOF(stod(args[2])), 0., stod(args[3]), NODE_TYPE_GROUNDSTATION);
                }
                else if (args.size() == 5)
                {
                    (*sit)->AddTarget(args[0], RADOF(stod(args[1])), RADOF(stod(args[2])), stod(args[3]), stod(args[4]), NODE_TYPE_TARGET);
                }
            }
        }
    }

    // Open socket for sending data to and from agent_propagator
    iretn = socket_open(&net_channel_in, NetworkType::UDP, "", net_port_in, SOCKET_LISTEN, SOCKET_NONBLOCKING);
//    iretn = socket_open(net_channel_out, net_port_out);
    iretn = socket_publish(net_channel_out, net_port_out);

    open_cosmos_web_sockets();

    add_sim_devices();
    // Reset simulation db
    reset_db();

    PacketComm packet;
    double elapsed = 0;
    double pcount = 0.;
    minaccel = maxaccel / minaccelratio;
    offset = motherutc - currentmjd();
    while (agent->running())
    {
        ElapsedTime ret;
        for (auto sit = sim->cnodes.begin(); sit != sim->cnodes.end(); sit++)
        {
            string output;
            output += (*sit)->currentinfo.get_json("node.utc");
            output += (*sit)->currentinfo.get_json("node.name");
            output += (*sit)->currentinfo.get_json("node.loc.pos.eci.s");
            output += (*sit)->currentinfo.get_json("node.loc.pos.eci.v");
            iretn = socket_post(net_channel_out, output);

            send_telem_to_cosmos_web(&(*sit)->currentinfo);
        }
//        iretn = PacketHandler::CreateBeacon(packet, static_cast<uint8_t>(Beacon::TypeId::NodeLocBeacon), agent);
//        iretn = socket_sendto(net_channel_out, packet.wrapped);
//        iretn = PacketHandler::CreateBeacon(packet, static_cast<uint8_t>(Beacon::TypeId::NodePhysBeacon), agent);
//        iretn = socket_sendto(net_channel_out, packet.wrapped);
//        iretn = PacketHandler::CreateBeacon(packet, static_cast<uint8_t>(Beacon::TypeId::NodeTargetBeacon), agent);
//        iretn = socket_sendto(net_channel_out, packet.wrapped);

        // Attitude adjustment
        // Desired attitude comes from aligning satellite Z with desired Z and satellite Y with desired Y
        qatt tatt;
        qatt satt;
        locstruc stloc;

        // update states information for all nodes
        sim->Propagate();
        pcount += simdt;

        ++elapsed;

        cout << "sim->currentutc: " << std::to_string(sim->currentutc) << endl;

        // Exit after sim completion
        if (endutc > 0. && sim->currentutc > endutc)
        {
            break;
        }

        secondsleep(simdt/speed - ret.lap());
    }

    // Final propagator code to run
    // OrbitalEventGenerator needs to force-end some events if they haven't finished yet.
    sim->End();

    // Find all sets of overlapping target viewing opportunities now that all
    // target events have been calculated.
    get_observation_windows();

    send_events_to_cosmos_web();

    agent->shutdown();
}


// Find all sets of overlapping target viewing opportunities
void get_observation_windows()
{
    // Per node
    vector<eventstruc*> events;
    for (auto cnode = sim->cnodes.begin(); cnode != sim->cnodes.end(); cnode++)
    {
        cout << "\nNode: " << (*cnode)->currentinfo.node.name << endl;
        events.clear();
        for (auto event = (*cnode)->currentinfo.event.begin(); event != (*cnode)->currentinfo.event.end(); event++)
        {
            if (event->type == EVENT_TYPE_TARG)
            {
                events.push_back(&*event);
            }
        }
        event_union_utc(events);
    }

    // Whole swarm
    cout << "\nSwarm: " << endl;
    events.clear();
    for (auto cnode = sim->cnodes.begin(); cnode != sim->cnodes.end(); cnode++)
    {
        for (auto event = (*cnode)->currentinfo.event.begin(); event != (*cnode)->currentinfo.event.end(); event++)
        {
            if (event->type == EVENT_TYPE_TARG)
            {
                events.push_back(&*event);
            }
        }
    }
    event_union_utc(events);

}

// Get the list of unions of all events that overlap on time+duration
void event_union_utc(vector<eventstruc*> events)
{
    vector<observation_window> windows;
    observation_window window;
    window.type = 0;
    window.utc = 0.;
    window.duration = 0.;
    window.elems.clear();
    // Ascending sort by event starting utc time
    std::sort(events.begin(), events.end(),
        [](eventstruc* e1, eventstruc* e2)-> bool {
            return e1->utc < e2->utc;
        }
    );
    for (auto event = events.begin(); event != events.end(); event++)
    {
        if ((*event)->type != EVENT_TYPE_TARG)
        {
            continue;
        }
        // New window
        if ((window.utc + window.duration) < (*event)->utc)
        {
            if (event != events.begin())
            {
                // Don't push back the first event before starting to collect them
                windows.push_back(window);
            }
            window.type = EVENT_TYPE_TARG_OBSRV_WINDOW;
            window.utc = (*event)->utc;
            window.duration = (*event)->dtime;
            window.elems = { (*event)->name };
        }
        // Still within current window
        else
        {
            window.duration = ((*event)->utc - window.utc) + (*event)->dtime;
            window.elems.push_back((*event)->name);
        }
        // Push back if last event
        if (event == events.end()-1)
        {
            windows.push_back(window);
        }
    }
    // Do something with the discovered windows
    for (auto it = windows.begin(); it != windows.end(); it++)
    {
        string ret = "";
        vector<string> targets;
        for (auto el = it->elems.begin(); el != it->elems.end(); el++)
        {
            if (std::find(targets.begin(), targets.end(), *el) == targets.end())
            {
                targets.push_back(*el);
                ret += *el + ", ";
            }
        }
        cout << "startutc: " << std::left << std::setw(20) << std::setprecision(std::numeric_limits<double>::max_digits10) << it->utc
            << " endutc: " << std::left << std::setw(20) << std::setprecision(std::numeric_limits<double>::max_digits10) << (it->utc + it->duration)
            << " targets: " << ret << endl;
    }
}

// Open sockets for sending data to cosmos web
int32_t open_cosmos_web_sockets()
{
    // No telems are to be emitted if no address was specified
    if (cosmos_web_addr.empty())
    {
        return 0;
    }
    if (cosmos_web_addr.find(".") == std::string::npos && cosmos_web_addr.find(":") == std::string::npos)
    {
        string response;
        int32_t iretn = hostnameToIP(TELEGRAF_ADDR, cosmos_web_addr, response);
        if (iretn < 0)
        {
            cout << "Encountered error in hostnameToIP: " << response << endl;
            exit(0);
        }
    }

    int32_t iretn = socket_open(&cosmos_web_telegraf_channel, NetworkType::UDP, cosmos_web_addr.c_str(), TELEGRAF_PORT, SOCKET_TALK, SOCKET_BLOCKING, 2000000 );
    if ((iretn) < 0)
    {
        cout << "Failed to open socket cosmos_web_telegraf_channel: " << cosmos_error_string(iretn) << endl;
        exit(0);
    }
    iretn = socket_open(&cosmos_web_api_channel, NetworkType::UDP, cosmos_web_addr.c_str(), API_PORT, SOCKET_TALK, SOCKET_BLOCKING, 2000000);
    if ((iretn) < 0)
    {
        cout << "Failed to open socket cosmos_web_api_channel: " << cosmos_error_string(iretn) << endl;
        exit(0);
    }
    return iretn;
}

int32_t parse_control(string args)
{
    uint16_t argcount = 0;
    string estring;
    json11::Json jargs = json11::Json::parse(args, estring);
    if (!jargs["speed"].is_null())
    {
        ++argcount;
        speed = jargs["speed"].number_value();
    }
    if (!jargs["motherutc"].is_null())
    {
        ++argcount;
        motherutc = jargs["motherutc"].number_value();
    }
    if (!jargs["endutc"].is_null())
    {
        ++argcount;
        endutc = jargs["endutc"].number_value();
    }
    if (!jargs["simdt"].is_null())
    {
        ++argcount;
        simdt = jargs["simdt"].number_value();
    }
    if (!jargs["minaccelratio"].is_null())
    {
        ++argcount;
        minaccelratio = jargs["minaccelratio"].number_value();
    }
    if (!jargs["targetfile"].is_null())
    {
        ++argcount;
        targetfile = jargs["targetfile"].string_value();
    }
    if (!jargs["realmname"].is_null())
    {
        ++argcount;
        realmname = jargs["realmname"].string_value();
    }
    if (!jargs["cosmos_web_addr"].is_null())
    {
        ++argcount;
        cosmos_web_addr = jargs["cosmos_web_addr"].string_value();
    }

    return argcount;
}

// If the propagate realm doesn't exist, then write the default files
// See files in ~/cosmos/core/data/demo/
void check_propagator_setup_files()
{
    string realmdir = get_realmdir(realmname, true);
    satfile = realmdir + "/" + satfile;
    targetfile = realmdir + "/" + targetfile;
    tlefile = realmdir + "/" + tlefile;
    if (!data_exists(satfile))
    {
        std::ofstream  dst(satfile, std::ios::binary);
        dst << sat_default;
        dst.close();
    }
    if (!data_exists(targetfile))
    {
        std::ofstream  dst(targetfile, std::ios::binary);
        dst << target_default;
        dst.close();
    }
    if (!data_exists(tlefile))
    {
        std::ofstream  dst(tlefile, std::ios::binary);
        dst << tle_default;
        dst.close();
    }
}

int32_t parse_sat(string args)
{
    int32_t iretn;
    string nodename;
    double initiallat = RADOF(21.3069);
    double initiallon = RADOF(-157.8583);
    double initialalt = 400000.;
    double initialangle = RADOF(54.);
    Convert::locstruc initialloc;
    tlestruc initialtle;
    vector<camstruc> dets;

    uint16_t argcount = 0;
    string estring;
    json11::Json jargs = json11::Json::parse(args, estring);
//    initialloc = Physics::shape2eci(motherutc, initiallat, initiallon, initialalt, initialangle, 0.);
    Physics::Propagator::Type type = Physics::Propagator::PositionInertial;
    if (!jargs["detector"].is_null())
    {
        ++argcount;
        json11::Json::object values = jargs["detector"].object_items();
        dets.resize(dets.size()+1);
        dets.back().fov = values["fov"].number_value();
        dets.back().ifov = values["ifov"].number_value();
        dets.back().specmin = values["specmin"].number_value();
        dets.back().specmax = values["specmax"].number_value();
    }
    if (!jargs["maxaccel"].is_null())
    {
        ++argcount;
        maxaccel = jargs["maxaccel"].number_value();
    }
    if (!jargs["lvlh"].is_null())
    {
        ++argcount;
        json11::Json::object values = jargs["lvlh"].object_items();
        Physics::Simulator::StateList::iterator sit = sim->GetNode("mother");
        initialloc = (*sit)->currentinfo.node.loc;
        cartpos lvlh;
        lvlh.s.col[0] = values["x"].number_value();
        lvlh.s.col[1] = values["y"].number_value();
        lvlh.s.col[2] = values["z"].number_value();
        lvlh.v.col[0] = values["vx"].number_value();
        lvlh.v.col[1] = values["vy"].number_value();
        lvlh.v.col[2] = values["vz"].number_value();
        lvlh.pass++;
        pos_origin2lvlh(initialloc, lvlh);
        type = Physics::Propagator::PositionLvlh;
    }
    if (!jargs["ric"].is_null())
    {
        ++argcount;
        json11::Json::object values = jargs["ric"].object_items();
        Physics::Simulator::StateList::iterator sit = sim->GetNode("mother");
        initialloc = (*sit)->currentinfo.node.loc;
        Convert::locstruc basepos = initialloc;
        rvector ric = { values["r"].number_value(), values["i"].number_value(), values["c"].number_value() };
        ric2eci((*sit)->currentinfo.node.loc.pos.eci, ric, initialloc.pos.eci);
        initialloc.pos.eci.pass+=2;
        pos_eci(initialloc);
        // Store RIC as LVLH as well
        Convert::cartpos geoc_offset;
        geoc_offset.s = rv_sub(initialloc.pos.geoc.s, basepos.pos.geoc.s);
        geoc_offset.v = rv_sub(initialloc.pos.geoc.v, basepos.pos.geoc.v);
        geoc_offset.a = rv_sub(initialloc.pos.geoc.a, basepos.pos.geoc.a);
        initialloc.pos.lvlh.s = irotate(basepos.pos.extra.g2l, geoc_offset.s);
        initialloc.pos.lvlh.v = irotate(basepos.pos.extra.g2l, geoc_offset.v);
        initialloc.pos.lvlh.a = irotate(basepos.pos.extra.g2l, geoc_offset.a);
        initialloc.pos.lvlh.utc = initialloc.pos.utc;
        type = Physics::Propagator::PositionLvlh;
    }
    if (!jargs["phys"].is_null())
    {
        ++argcount;
        json11::Json::object values = jargs["phys"].object_items();
        initiallat = RADOF(values["lat"].number_value());
        initiallon = RADOF(values["lon"].number_value());
        initialalt = values["alt"].number_value();
        initialangle = RADOF(values["angle"].number_value());
        if (motherutc == 0.)
        {
            motherutc = currentmjd();
        }
        initialloc = Physics::shape2eci(motherutc, initiallat, initiallon, initialalt, initialangle, 0.);
        type = Physics::Propagator::PositionIterative;
    }
    if (!jargs["eci"].is_null())
    {
        ++argcount;
        json11::Json::object values = jargs["eci"].object_items();
        initialloc.pos.eci.utc = (values["utc"].number_value());
        initialloc.pos.eci.s.col[0] = (values["x"].number_value());
        initialloc.pos.eci.s.col[1] = (values["y"].number_value());
        initialloc.pos.eci.s.col[2] = (values["z"].number_value());
        initialloc.pos.eci.v.col[0] = (values["vx"].number_value());
        initialloc.pos.eci.v.col[1] = (values["vy"].number_value());
        initialloc.pos.eci.v.col[2] = (values["vz"].number_value());
        initialloc.pos.eci.pass++;
        pos_eci(initialloc);
        eci2tle(motherutc, initialloc.pos.eci, initialtle);
        type = Physics::Propagator::PositionTle;
    }
    if (!jargs["kep"].is_null())
    {
        ++argcount;
        json11::Json::object values = jargs["kep"].object_items();
        kepstruc kep;
        if (motherutc == 0.)
        {
            motherutc = currentmjd();
        }
        kep.utc = motherutc;
        kep.ea = values["ea"].number_value();
        kep.i = values["i"].number_value();
        kep.ap = values["ap"].number_value();
        kep.raan = values["raan"].number_value();
        kep.e = values["e"].number_value();
        kep.a = values["a"].number_value();
        kep2eci(kep, initialloc.pos.eci);
        initialloc.pos.eci.pass++;
        pos_eci(initialloc);
        eci2tle(motherutc, initialloc.pos.eci, initialtle);
        type = Physics::Propagator::PositionTle;
    }
    if (!jargs["tle"].is_null())
    {
        ++argcount;
        json11::Json::object values = jargs["tle"].object_items();
        vector<Convert::tlestruc>lines;
        string fname = get_realmdir(realmname, true) + "/" + values["filename"].string_value();
        load_lines(fname, lines);
        if (motherutc == 0.)
        {
            motherutc = lines[0].utc;
        }
        lines2eci(motherutc, lines, initialloc.pos.eci);
        initialloc.pos.eci.pass++;
        pos_eci(initialloc);
        initialtle = lines[0];
        type = Physics::Propagator::PositionTle;
    }
    initialloc.att.lvlh.s = q_eye();
    ++initialloc.att.lvlh.pass;
    att_lvlh(initialloc);
    if (!sim->cnodes.size())
    {
        nodename = "mother";
        motherutc = initialloc.utc;
        mothericrf = initialloc.att.icrf;
        mothereci = initialloc.pos.eci;
        iretn = sim->AddNode(nodename, Physics::Structure::HEX65W80H, Physics::Propagator::PositionTle, Physics::Propagator::AttitudeLVLH, Physics::Propagator::Thermal, Physics::Propagator::Electrical, initialloc.pos.eci, initialloc.att.icrf);
    }
    else
    {
        nodename = "child_" + to_unsigned(sim->cnodes.size(), 2, true);
        // TODO: position initialization should be independent from what position propagator is desired
        if (type == Physics::Propagator::PositionLvlh)
        {
            iretn = sim->AddNode(nodename, Physics::Structure::U12, Physics::Propagator::PositionLvlh, Physics::Propagator::AttitudeTarget, Physics::Propagator::Thermal, Physics::Propagator::Electrical, initialloc.pos.lvlh, mothereci, mothericrf);
        }
        else
        {
            iretn = sim->AddNode(nodename, Physics::Structure::U12, Physics::Propagator::PositionTle, Physics::Propagator::AttitudeTarget, Physics::Propagator::Thermal, Physics::Propagator::Electrical, initialloc.pos.eci, mothericrf);
        }
    }
    Physics::Simulator::StateList::iterator sit = sim->GetNode(nodename);
    for (camstruc det : dets)
    {
        (*sit)->currentinfo.devspec.cam.push_back(det);
    }
    (*sit)->currentinfo.devspec.cam_cnt = dets.size();
    return iretn;
}

int32_t parse_target(string args)
{
//    int32_t iretn;
    string name;
    NODE_TYPE type = NODE_TYPE_TARGET;
    double clat = RADOF(21.3069);
    double clon = RADOF(-157.8583);
    double dlat = 0.;
    double dlon = 0.;
    double alt = 0.;
    uint16_t argcount = 0;
    string estring;
    json11::Json jargs = json11::Json::parse(args, estring);
    if (!jargs["name"].is_null())
    {
        ++argcount;
        name = jargs["name"].string_value();
    }
    if (!jargs["type"].is_null())
    {
        ++argcount;
        type = static_cast<NODE_TYPE>(jargs["type"].number_value());
    }
    if (!jargs["alt"].is_null())
    {
        ++argcount;
        alt = jargs["alt"].number_value();
    }
    if (!jargs["clat"].is_null())
    {
        ++argcount;
        clat = jargs["clat"].number_value();
    }
    if (!jargs["clon"].is_null())
    {
        ++argcount;
        clon = jargs["clon"].number_value();
    }
    if (!jargs["dlat"].is_null())
    {
        ++argcount;
        dlat = jargs["dlat"].number_value();
    }
    if (!jargs["dlon"].is_null())
    {
        ++argcount;
        dlon = jargs["dlon"].number_value();
    }
    for (Physics::Simulator::StateList::iterator sit = sim->cnodes.begin(); sit != sim->cnodes.end(); sit++)
    {
        (*sit)->AddTarget(name, clat+dlat, clon-dlon, clat-dlat, clon+dlon, alt, type);
    }
    return sim->cnodes.size();
}

/**
 * @brief Sends a single node's telems to cosmos web
 * 
 * @param cinfo cosmosstruc of some node to store telems for
 * @return int32_t 0 on success, negative on failure
 */
int32_t send_telem_to_cosmos_web(cosmosstruc* cinfo)
{
    if (cosmos_web_addr.empty())
    {
        return 0;
    }
    // locstruc
    json11::Json jobj = json11::Json::object({
        {"node_name", cinfo->node.name },
        {"node_loc", json11::Json::object({
            {"pos", json11::Json::object({
                {"eci", json11::Json::object({
                    { "utc", cinfo->node.loc.pos.eci.utc },
                    { "s", cinfo->node.loc.pos.eci.s },
                    { "v", cinfo->node.loc.pos.eci.v }
                })}
            })},
            {"att", json11::Json::object({
                {"icrf", json11::Json::object({
                    { "utc", cinfo->node.loc.att.icrf.utc },
                    { "s", cinfo->node.loc.att.icrf.s },
                    { "v", cinfo->node.loc.att.icrf.v }
                })}
            })}
        })},
    });
    int32_t iretn = socket_sendto(cosmos_web_telegraf_channel, jobj.dump());
    // int32_t iretn = 0; cout << jobj.dump() << endl;
    if (iretn < 0) { return iretn; }

    // Devices are not auto-populated, so just use some RANDOM VALUES
    // battstruc
    jobj = json11::Json::object({
        {"node_name", cinfo->node.name },
        {"devspec", json11::Json::object({
            {"batt", [cinfo]() -> vector<json11::Json>
                {
                    vector<json11::Json> ret;
                    for (auto batt : cinfo->devspec.batt) {
                        batt.amp = (rand()/(double)RAND_MAX) * (1.-0.5) +0.5;
                        batt.volt = (rand()/(double)RAND_MAX) * (8.-5.) +5.;
                        batt.power = batt.amp * batt.volt;
                        ret.push_back({
                            json11::Json::object({
                                {"didx", batt.didx},
                                {"utc", sim->currentutc},
                                {"amp", batt.amp},
                                {"volt", batt.volt},
                                {"power", batt.power},
                                {"temp", (rand()/(double)RAND_MAX) * (400.-375.) +375.},
                                {"percentage", (rand()/(double)RAND_MAX) * (0.65-0.35) +0.35},
                            })
                        });
                    }
                    return ret;
                }()
            }
        })}
    });
    iretn = socket_sendto(cosmos_web_telegraf_channel, jobj.dump());
    if (iretn < 0) { return iretn; }

    // bcregstruc
    jobj = json11::Json::object({
        {"node_name", cinfo->node.name },
        {"devspec", json11::Json::object({
            {"bcreg", [cinfo]() -> vector<json11::Json>
                {
                    vector<json11::Json> ret;
                    for (auto bcr : cinfo->devspec.bcreg) {
                        bcr.amp = (rand()/(double)RAND_MAX) * (1.-0.5) +0.5;
                        bcr.volt = (rand()/(double)RAND_MAX) * (8.-5.) +5.;
                        bcr.power = bcr.amp * bcr.volt;
                        ret.push_back({
                            json11::Json::object({
                                {"didx", bcr.didx},
                                {"utc", sim->currentutc},
                                {"amp", bcr.amp},
                                {"volt", bcr.volt},
                                {"power", bcr.power},
                                {"temp", (rand()/(double)RAND_MAX) * (400.-375.) +375.},
                                {"mpptin_amp", bcr.amp * 0.9},
                                {"mpptin_volt", bcr.volt * 0.9},
                                {"mpptout_amp", bcr.amp * 0.5},
                                {"mpptout_volt", bcr.volt * 0.5},
                            })
                        });
                    }
                    return ret;
                }()
            }
        })}
    });
    iretn = socket_sendto(cosmos_web_telegraf_channel, jobj.dump());
    if (iretn < 0) { return iretn; }

    // cpustruc
    jobj = json11::Json::object({
        {"node_name", cinfo->node.name },
        {"devspec", json11::Json::object({
            {"cpu", [cinfo]() -> vector<json11::Json>
                {
                    vector<json11::Json> ret;
                    for (auto cpu : cinfo->devspec.cpu) {
                        ret.push_back({
                            json11::Json::object({
                                {"didx", cpu.didx},
                                {"utc", sim->currentutc},
                                {"temp", (rand()/(double)RAND_MAX) * (400.-375.) +375.},
                                {"uptime", sim->currentutc - 59945.0}, // 01/01/2023 TODO: breaks db code if negative
                                {"gib", (rand()/(double)RAND_MAX) * (4.-2.) +2.},
                                {"load", (rand()/(double)RAND_MAX) * (0.95-0.5) +0.5},
                                {"boot_count", 2},
                                {"storage", (rand()/(double)RAND_MAX) * (25.-9.) +9.},
                            })
                        });
                    }
                    return ret;
                }()
            }
        })}
    });
    iretn = socket_sendto(cosmos_web_telegraf_channel, jobj.dump());
    if (iretn < 0) { return iretn; }

    // tsenstruc
    jobj = json11::Json::object({
        {"node_name", cinfo->node.name },
        {"devspec", json11::Json::object({
            {"tsen", [cinfo]() -> vector<json11::Json>
                {
                    vector<json11::Json> ret;
                    for (auto tsen : cinfo->devspec.tsen) {
                        ret.push_back({
                            json11::Json::object({
                                {"didx", tsen.didx},
                                {"utc", sim->currentutc},
                                {"temp", (rand()/(double)RAND_MAX) * (400.-375.) +375.},
                            })
                        });
                    }
                    return ret;
                }()
            }
        })}
    });
    iretn = socket_sendto(cosmos_web_telegraf_channel, jobj.dump());
    if (iretn < 0) { return iretn; }

    return 0;
}

void send_events_to_cosmos_web()
{
    for (auto cnode = sim->cnodes.begin(); cnode != sim->cnodes.end(); cnode++)
    {
        json11::Json jobj = json11::Json::object({
            {"event", [cnode]() -> vector<json11::Json>
                {
                    vector<json11::Json> ret;
                    // Event id is currently arbitrary
                    uint16_t event_id = 0;
                    for (auto event : (*cnode)->currentinfo.event) {
                        ret.push_back({
                            json11::Json::object({
                                { "node_name"  , (*cnode)->currentinfo.node.name },
                                { "utc", event.utc },
                                { "duration", event.dtime },
                                { "event_id" , event_id++ },
                                { "type" , static_cast<int32_t>(event.type) },
                                { "event_name" , event.name },
                            })
                        });
                    }
                    return ret;
                }()
            }
        });
        socket_sendto(cosmos_web_telegraf_channel, jobj.dump());
    }
}

/**
 * @brief Add devices to simulate to the nodes
 */
void add_sim_devices()
{
    for (auto sit = sim->cnodes.begin(); sit != sim->cnodes.end(); sit++)
    {
        // Battery
        for (size_t i=0; i < 2; ++i) {
            json_createpiece(&(*sit)->currentinfo, "Battery"+std::to_string(i), DeviceType::BATT);
        }
        // BC Regulators (solar panels)
        json_createpiece(&(*sit)->currentinfo, "Left", DeviceType::BCREG);
        json_createpiece(&(*sit)->currentinfo, "Right", DeviceType::BCREG);
        // CPU
        json_createpiece(&(*sit)->currentinfo, "iOBC", DeviceType::CPU);
        json_createpiece(&(*sit)->currentinfo, "iX5-100", DeviceType::CPU);
        // Thermal Sensors
        json_createpiece(&(*sit)->currentinfo, "Camera", DeviceType::TSEN);
        json_createpiece(&(*sit)->currentinfo, "Heat sink", DeviceType::TSEN);
        json_createpiece(&(*sit)->currentinfo, "CPU", DeviceType::TSEN);

        // Fix pointers
        json_updatecosmosstruc(&(*sit)->currentinfo);
        // Update all physical quantities
        node_calc(&(*sit)->currentinfo);
    }
}

/**
 * @brief Reset the simulation database
 */
void reset_db()
{
    if (cosmos_web_addr.empty())
    {
        return;
    }
    socket_sendto(cosmos_web_api_channel, "{\"swchstruc\": true, \"battstruc\": true, \"bcregstruc\": true, \"cpustruc\": true, \"device\": true, \"device_type\": true, \"locstruc\": true, \"magstruc\": true, \"node\": true, \"tsenstruc\": true, \"rwstruc\": true, \"mtrstruc\": true, \"attstruc_icrf\": true, \"cosmos_event\": true, \"event_type\": true, \"gyrostruc\": true, \"locstruc_eci\": true, \"target\": true, \"cosmos_event\": true }");
    // Iterate over sats
    uint16_t node_id = 1;
    for (auto sit = sim->cnodes.begin(); sit != sim->cnodes.end(); sit++)
    {
        // Compute node id manually until it's stored somewhere in cosmosstruc
        uint16_t id = node_id;
        (*sit)->currentinfo.node.name == "mother" ? id = 0 : ++node_id;

        // Repopulate node table
        json11::Json jobj = json11::Json::object({
            {"node", json11::Json::object({
                { "node_id", id },
                { "node_name", (*sit)->currentinfo.node.name },
                { "node_type", NODE_TYPE_SATELLITE },
                { "agent_name", (*sit)->currentinfo.agent0.name },
                { "utc", sim->currentutc },
                { "utcstart", currentutc }
            })}
        });
        socket_sendto(cosmos_web_telegraf_channel, jobj.dump());
        // Add device info
        jobj = json11::Json::object({
            {"node_name", (*sit)->currentinfo.node.name },
            {"device", [id, sit]() -> vector<json11::Json>
                {
                    vector<json11::Json> ret;
                    for (auto device : (*sit)->currentinfo.device) {
                        ret.push_back({
                            json11::Json::object({
                                { "type", device->type },
                                { "cidx", device->cidx },
                                { "didx", device->didx },
                                { "name", device->name }
                            })
                        });
                    }
                    return ret;
                }()
            }
        });
        socket_sendto(cosmos_web_telegraf_channel, jobj.dump());
    }
    auto mother = sim->GetNode("mother");
    if (mother != sim->cnodes.end())
    {
        // Groundstations & targets
        json11::Json jobj = json11::Json::object({
            {"target", [mother]() -> vector<json11::Json>
                {
                    vector<json11::Json> ret;
                    uint16_t target_id = 0;
                    for (auto target : (*mother)->currentinfo.target) {
                        ret.push_back({
                            json11::Json::object({
                                { "id"  , target_id++ },
                                { "name", target.name },
                                { "type", target.type },
                                { "lat" , target.loc.pos.geod.s.lat },
                                { "lon" , target.loc.pos.geod.s.lon },
                                { "h" , target.loc.pos.geod.s.h },
                                { "area" , target.area }
                            })
                        });
                    }
                    return ret;
                }()
            }
        });
        socket_sendto(cosmos_web_telegraf_channel, jobj.dump());
    }
    // cout << "Resetting db..." << endl;
    secondsleep(1.);
}
